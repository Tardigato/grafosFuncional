<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grafo con Dijkstra</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet">
</head>
<body>
  <div id="lienzo" style="width: 800px; height: 600px; border: 1px solid black;"></div>
  <div>
    <button onclick="agregarNodo()">Agregar Nodo</button>
    <button onclick="activarModoEliminarArista()">Eliminar Arista</button>
    <button onclick="generarMatriz()">Generar Matriz</button>
    <button onclick="guardarGrafo()">Guardar Grafo</button>
    <input type="file" id="inputArchivo" onchange="cargarGrafo()">
    <button onclick="cargarGrafo()">Cargar Grafo</button>
  </div>
  <div>
    <label for="nodoInicio">Nodo Inicio:</label>
    <input type="text" id="nodoInicio" placeholder="ID Nodo Inicio">
    <label for="nodoDestino">Nodo Destino:</label>
    <input type="text" id="nodoDestino" placeholder="ID Nodo Destino">
    <button onclick="calcularRutaMasCorta()">Calcular Ruta Más Corta</button>
  </div>
  <div id="matriz"></div>
  <div id="listaHolguras"></div>
  <script>
    let grafo;
    let nodosDataSet;
    let aristasDataSet;
    let seleccionado;
    let modoEliminarArista = false;
    let modoAgregarNodo = false;
    let aristasDataSetBackup; // Variable para almacenar una copia de seguridad de las aristas

function inicializarGrafo() {
  const lienzo = document.getElementById('lienzo');
  nodosDataSet = new vis.DataSet();
  aristasDataSet = new vis.DataSet();
  const data = { nodes: nodosDataSet, edges: aristasDataSet };
  const opciones = {};
  grafo = new vis.Network(lienzo, data, opciones);

  grafo.on('click', clicEnNodo);
  grafo.on('doubleClick', dobleClicEnArista);
  grafo.on('click', eliminarAristaSeleccionada);

  // Crear una copia de seguridad de las aristas
  aristasDataSetBackup = new vis.DataSet();
  aristasDataSet.forEach(arista => {
    aristasDataSetBackup.add(arista);
  });
}



  // El resto del código de cálculo de la ruta más corta sigue igual...


   

    var options = {
      physics: {
        enabled: false
      }
    };

    function clicEnNodo(propiedades) {
      const { nodes } = propiedades;
      if (nodes.length > 0) {
        if (seleccionado === undefined) {
          seleccionado = nodes[0];
        } else {
          if (seleccionado !== nodes[0]) {
            aristasDataSet.add({ from: seleccionado, to: nodes[0], arrows: 'to', label: '1' });
            seleccionado = undefined;
          } else {
            aristasDataSet.add({ from: seleccionado, to: seleccionado, arrows: 'to', label: '1' });
            seleccionado = undefined;
          }
        }
      }
    }

    function dobleClicEnArista(propiedades) {
      const { edges } = propiedades;
      if (edges.length > 0) {
        const valor = prompt('Ingrese el valor para la conexión:', '1');
        if (valor !== null) {
          aristasDataSet.update({ id: edges[0], label: valor });
        }
      }
    }

    function eliminarAristaSeleccionada(propiedades) {
      if (modoEliminarArista) {
        const aristaId = propiedades.edges[0];
        if (aristaId !== undefined) {
          eliminarArista(aristaId);
          modoEliminarArista = false;
        }
      }
    }

    function activarModoEliminarArista() {
      modoEliminarArista = true;
      alert('Haz clic en la arista que deseas eliminar.');
    }

    function eliminarArista(aristaId) {
      aristasDataSet.remove({ id: aristaId });
    }

    document.addEventListener('keydown', function(event) {
      if (event.key === 'Delete' || event.key === 'Backspace') {
        const seleccion = grafo.getSelection();
        if (seleccion.edges.length > 0) {
          eliminarArista(seleccion.edges[0]);
        }
      }
    });

    function agregarNodo() {
      modoAgregarNodo = true;
      grafo.off('click');
      grafo.on('click', function(event) {
        if (modoAgregarNodo) {
          const position = event.pointer.canvas;
          const nuevoId = nodosDataSet.length + 1;
          nodosDataSet.add({ id: nuevoId, label: 'Nodo ' + nuevoId, x: position.x, y: position.y });
          grafo.off('click');
          grafo.on('click', clicEnNodo);
          modoAgregarNodo = false;
        }
      });
    }

    function cambiarNombre() {
      if (seleccionado !== undefined) {
        const nuevoNombre = prompt('Ingrese el nuevo nombre para el nodo:', seleccionado.label);
        if (nuevoNombre !== null) {
          nodosDataSet.update({ id: seleccionado, label: nuevoNombre });
        }
        seleccionado = undefined;
      } else {
        alert('Por favor, seleccione un nodo primero.');
      }
    }

    function eliminarNodo() {
      if (seleccionado !== undefined) {
        nodosDataSet.remove({ id: seleccionado });
        const aristas = aristasDataSet.get({ filter: function (item) { return item.from === seleccionado || item.to === seleccionado; } });
        aristas.forEach(function (arista) {
          aristasDataSet.remove({ id: arista.id });
        });
      } else {
        alert('Por favor, seleccione un nodo primero.');
      }
    }

    function generarMatriz() {
      const nodos = nodosDataSet.get({ fields: ['id', 'label'] });
      const matriz = [];
      const sumasFilas = [];
      const sumasColumnas = new Array(nodos.length).fill(0);
      
      nodos.forEach((nodo, rowIndex) => {
        const fila = [];
        let sumaFila = 0;
        nodos.forEach((otroNodo, columnIndex) => {
          const conexion = aristasDataSet.get({
            filter: edge => (edge.from === nodo.id && edge.to === otroNodo.id)
          });
          if (conexion.length > 0) {
            const valor = parseInt(conexion[0].label || 1);
            fila.push(valor);
            sumaFila += valor;
            sumasColumnas[columnIndex] += valor;
          } else {
            fila.push(0);
          }
        });
        matriz.push(fila);
        sumasFilas.push(sumaFila);
      });

      mostrarMatriz(nodos, matriz, sumasFilas, sumasColumnas);
    }

    function mostrarMatriz(nodos, matriz, sumasFilas, sumasColumnas) {
      const contenedorMatriz = document.getElementById('matriz');
      let html = '<h2>Matriz de Adyacencia</h2>';
      html += '<table style="padding: 10px;border: 2px solid black;">';
      html += '<tr><th style="padding: 10px;border: 2px solid black;background-color: green;"></th>';
      nodos.forEach((nodo, index) => {
        html += `<th style="padding: 10px;border: 2px solid black;background-color: green;">${nodo.label}</th>`;
      });
      html += '<th style="padding: 10px;border: 2px solid black;background-color: green;">Suma por Fila</th>';
      html += '</tr>';
      matriz.forEach((fila, index) => {
        html += `<tr><th style="padding: 10px;border: 2px solid black;background-color: red;">${nodos[index].label}</th>`;
        fila.forEach(valor => {
          html += `<td style="padding: 10px;border: 2px solid black;">${valor}</td>`;
        });
        html += `<td style="padding: 10px;border: 2px solid black;">${sumasFilas[index]}</td>`;
        html += '</tr>';
      });
      html += '<tr><th style="padding: 10px;border: 2px solid black;background-color: red;">Suma por Columna</th>';
      sumasColumnas.forEach(suma => {
        html += `<td style="padding: 10px;border: 2px solid black;">${suma}</td>`;
      });
      html += '<td></td></tr>';
      html += '</table>';
      contenedorMatriz.innerHTML = html;
    }

    document.addEventListener('DOMContentLoaded', () => {
        inicializarGrafo();
      });
      
      // Función para guardar el grafo con un nombre proporcionado por el usuario
      function guardarGrafo() {
        aristasDataSet.forEach(edge => {
            aristasDataSet.update({ id: edge.id, color: { color: 'blue', highlight: 'blue' } });
        });
        const nombreArchivo = prompt('Por favor, ingresa un nombre para guardar el grafo:', 'grafo');
        if (nombreArchivo !== null) {
          const grafoJSON = JSON.stringify({ nodos: nodosDataSet.get(), aristas: aristasDataSet.get() });
          const blob = new Blob([grafoJSON], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = nombreArchivo + '.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      }
      
      // Función para cargar un grafo desde un archivo JSON seleccionado por el usuario
      function cargarGrafo() {
        const inputArchivo = document.getElementById('inputArchivo');
        const file = inputArchivo.files[0];
        const reader = new FileReader();
        reader.onload = function(event) {
          const contenido = event.target.result;
          const datos = JSON.parse(contenido);
          // Limpiar los conjuntos de datos actuales
          nodosDataSet.clear();
          aristasDataSet.clear();
          // Agregar los nodos y aristas del archivo JSON al grafo
          nodosDataSet.add(datos.nodos);
          aristasDataSet.add(datos.aristas);
        };
        reader.readAsText(file);
      }
      

    function calcularRutaMasCorta() {
        aristasDataSet.forEach(edge => {
            aristasDataSet.update({ id: edge.id, color: { color: 'blue', highlight: 'blue' } });
        });
        const nodoInicio = parseInt(document.getElementById('nodoInicio').value);
        const nodoDestino = parseInt(document.getElementById('nodoDestino').value);
  
        if (isNaN(nodoInicio) || isNaN(nodoDestino)) {
          alert('Por favor, ingrese nodos de inicio y destino válidos.');
          return;
        }
  
        const distancia = {};
        const previo = {};
        const nodos = nodosDataSet.get({ fields: ['id'] });
        const aristas = aristasDataSet.get();
  
        nodos.forEach(nodo => {
          distancia[nodo.id] = Infinity;
          previo[nodo.id] = null;
        });
  
        distancia[nodoInicio] = 0;
  
        const nodosSinVisitar = new Set(nodos.map(n => n.id));
  
        while (nodosSinVisitar.size > 0) {
          let nodoActual = null;
  
          nodosSinVisitar.forEach(nodo => {
            if (nodoActual === null || distancia[nodo] < distancia[nodoActual]) {
              nodoActual = nodo;
            }
          });
  
          if (distancia[nodoActual] === Infinity) {
            break;
          }
  
          nodosSinVisitar.delete(nodoActual);
  
          aristas.forEach(arista => {
            if (arista.from === nodoActual && nodosSinVisitar.has(arista.to)) {
              const distanciaAlternativa = distancia[nodoActual] + parseInt(arista.label);
              if (distanciaAlternativa < distancia[arista.to]) {
                distancia[arista.to] = distanciaAlternativa;
                previo[arista.to] = nodoActual;
              }
            }
          });
        }
  
        const ruta = [];
        let nodo = nodoDestino;
  
        while (nodo !== null) {
          ruta.unshift(nodo);
          nodo = previo[nodo];
        }
  
        if (ruta[0] !== nodoInicio) {
          alert('No se encontró una ruta desde el nodo de inicio al nodo de destino.');
        } else {
          alert('Ruta más corta: ' + ruta.join(' -> '));
          
          // Resaltar las aristas del camino más corto
          
                // Resaltar las aristas del camino más corto
      for (let i = 0; i < ruta.length - 1; i++) {
        const aristasEnRuta = aristasDataSet.get({
          filter: edge =>
            (edge.from === ruta[i] && edge.to === ruta[i + 1]) ||
            (edge.to === ruta[i] && edge.from === ruta[i + 1])
        });

        aristasEnRuta.forEach(arista => {
          aristasDataSet.update({ id: arista.id, color: { color: 'red' } });
        });
      }

        }
      
    }
  </script>
</body>
</html>
